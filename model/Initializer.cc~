#include "ns3/Initializer.h"

using std::stringstream;
using std::vector;
using std::queue;

namespace ns3 {

class CcnModule;

Initializer::Initializer(vector<Ptr<CcnModule> >* module, Ptr<Parser> parser,
		int dataOwner, std::string catalog,
		map<uint32_t, uint32_t> nodeToModule) {
	this->module = *module;
	this->parser = parser;
	this->dataOwner = dataOwner;
	this->dataNum = dataNum;
	this->nodeToModule = nodeToModule;

	for (uint32_t i = 0; i < module->size(); i++) {
		visited[module->at(i)->getNodeId()] = false;
	}
	parse_file_catalog(catalog);
}

char Initializer::parse_file_catalog(const string& catalog) {
	string line;
	std::ifstream myfile(catalog.c_str());
	if (myfile.is_open()) {
		while (getline(myfile, line)) {
			if (line.find_first_of("#") == 0)
				continue;
			string key = line.substr(0, line.find(" "));
			uint32_t size = atoi(line.substr(line.find(" ") + 1).c_str());
			file_map[key] = size;
		}
		myfile.close();
	}

	else
		std::cout << "Unable to open file";

	return 0;

}

Initializer::~Initializer() {
	//delete connection;
}

void Initializer::doesEveryModuleHaveANode() {
	for (uint32_t i = 0; i < module.size(); i++) {
		if (module.at(i)->getNode() == 0) {
			std::cout << "Module " << i << " does not have a node."
					<< std::endl;
		}
	}
}

/*
 * initialize forwarding rules!!
 * Should be done at file-level, because packet-level requires too much time. DONE!
 */
void Initializer::initializeFIBs() {
	queue < Ptr<CcnModule> > q = queue<Ptr<CcnModule> >(); //queue construction
	Ptr<CcnModule> ccnm = module.at(nodeToModule.find(dataOwner)->second);
	q.push(ccnm);
	visited[ccnm->getNodeId()] = true;

	//add FIBs from every network node to the publisher - inefficient
	vector < string > nameVector;
	nameVector.push_back(ROOT_DOMAIN);
	while (q.size() != 0) {
		Ptr<CcnModule> front_module = q.front();
		q.pop();

		map<Ptr<NetDevice>, Ptr<CcnModule> > neighbors =
				front_module->getNeighborModules();
		map<Ptr<NetDevice>, Ptr<CcnModule> >::iterator niter;
		for (niter = neighbors.begin(); niter != neighbors.end(); niter++) {
			
			Ptr<CcnModule> c = niter->second;
			if (visited[c->getNodeId()]) {
				continue;
			}
			visited[c->getNodeId()] = true;

					
			Ptr<CCN_Name> name = CreateObject < CCN_Name > (nameVector);
			c->getFIB()->put(name, ndfinder(front_module->getNode(), c->getNode()));
			
			q.push(c);
		}
		
	}

	std::cout << "BFS visited " << visited.size() << " nodes\n";
}

Ptr<CcnModule> Initializer::firstUnvisitedChild(Ptr<CcnModule> ccn) {
	map<Ptr<NetDevice>, Ptr<CcnModule> >::iterator it;
	for (it = ccn->getNeighborModules().begin();
			it != ccn->getNeighborModules().end(); it++) {
		Ptr<CcnModule> neighborModule = it->second;

		if (!visited[neighborModule->getNodeId()]) {
			return neighborModule;
		}
	}

	/*
	 for(unsigned i=0;i<ccn->getNode()->GetNDevices();i++)
	 {
	 if(!(this->visited.find(ccn->getNeighborModules().find(ccn->getNode()->GetDevice(i))->second)->second))
	 {
	 return ccn->getNeighborModules().find(ccn->getNode()->GetDevice(i))->second;
	 }

	 * if(!ccn->getNeighborModules().find(ccn->getNode()->GetDevice(i))->second->getNode()==0)//checking if its a real module (explained in BootstrappingHelper.cc)
	 {

	 }
	 }
	 */

	return 0;
}

Ptr<NetDevice> Initializer::ndfinder(Ptr<Node> n1, Ptr<Node> n2) //epistrefei to net device tou deksiou me to opoio o deksis syndeetai ston aristero
		{
	//	std::cout<<"ndfinder: "<<n1->GetId()<<" "<<n2->GetId()<<std::endl;

	if (n1 == 0) {
		std::cout << "In ndfinder in initializer n1 is null" << std::endl;
	}

	if (n2 == 0) {
		std::cout << "In ndfinder in initializer n2 is null" << std::endl;
	}

	for (unsigned i = 0; i < n2->GetNDevices(); i++) {
		if (n2->GetDevice(i)->GetChannel()->GetDevice(0)->GetNode() == n1) {
			return n2->GetDevice(i);
		}

		if (n2->GetDevice(i)->GetChannel()->GetDevice(1)->GetNode() == n1) {
			return n2->GetDevice(i);
		}
	}

	return 0;
}

/*
 * files
 * @int: seedfor random workloads
 * @vector: files to be downloaded
 */
vector<string> Initializer::create_workload(map<string, uint32_t> files,
		uint8_t seed) {
	vector < string > _workload;
	double * probabilities = new double[files.size()];
	uint8_t j = 0;
	uint16_t num_of_files = files.size();
	// weight will normalize probabilities to 1 for the least popular
	unsigned weight = ceil(pow(num_of_files, ZIPF_A));
	for (map<string, uint32_t>::iterator it = files.begin(); it != files.end();
			++it) {
		probabilities[j] = floor(weight * 1 / pow(j + 1, ZIPF_A));
		for (unsigned k = 0; k < probabilities[j]; k++)
			_workload.push_back(it->first);

		j++;
	}

	//randomly swap the downloads

	for (unsigned f = 0; f < _workload.size() / 2; f++) {
		for (unsigned i = 0; i < j; i++) {
			uint16_t A = i;
			uint16_t B = ExperimentGlobals::RANDOM_VAR->GetInteger(0,_workload.size()-1);

			string tmp = _workload.at(A);
			_workload.at(A) = _workload.at(B);
			_workload.at(B) = tmp;
		}
	}

	//std::cout<<"Overall there will be "<<_workload"
	delete[] probabilities;
	return _workload;
}

}
